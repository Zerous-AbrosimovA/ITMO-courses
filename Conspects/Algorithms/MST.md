# Критерий Тарьяна

Остовное дерево в неориентированном взвешенном графе минимально тогда и только тогда, когда для любого ребра, не принадлежащего остову, цикл, образуемый этим ребром при добавлении к остову, не содержит рёбер тяжелее этого ребра.

# Лемма о безопасном ребре в частичном MST

Рассмотрим связный неориентированный взвешенный граф G=(V,E) с весовой функцией w:E→ℝ. Пусть G′=(V,E′)\
— подграф некоторого минимального остовного дерева G, ⟨S,T⟩ — разрез G, такой, что ни одно ребро из E′\
не пересекает разрез, а (u,v) — ребро минимального веса среди всех ребер, пересекающих разрез ⟨S,T⟩.\ Тогда ребро e=(u,v) является безопасным для G′.

# Алгоритм Краскала

1) отсортируем все ребра графа в порядке неубывания
2) заицинилизируем ответ - как пустой граф на n вершинах
3) будем итерироваться по ребрам в порядке п.1 и добавлять ребро в ответ, если оно при своем добавление не образует цикл

```
sort(edges)
make_set(n)
for e in edges:
  if leader(e.u) != leader(e.v):
    mst.add(e)
    unite(e.u, e.v)
```

# DSU

1) создадим систему из n одноэлем. подмножества
2) leader(x) - возращает главного представителя подмножества, которое содержит элемент x
3) unite(u, v) - объединяет два подмножества, которое содержит u и которое содержит v

```
make_set(n)
  for i = 0...n-1:
    p[i] = i

leader(x):
  return x == p[x] ? x : p[x] = leader(p[x])

unite(u, v):
  u = leader(u)
  v = leader(v)
  if u != v:
    if (rank[u] > rank[v]) swap(u, v)
    p[u] = v
    if (rank[v] == rank[u])
      rank[v]++
```

# Алгоритм Прима

```
visited[] = [false, false, ...]
d[] = [inf, inf, ...]
d[s] = 0
p[] = [-1, -1, ...]
p[s] = s
while true:
  u = -1
  for i in 0...n-1
    if !visited[u] && (u == -1 || d[v] > d[i]): u = i
  if (u == -1 || d[u] = inf) break
  visited[u] = true
  for (u, v) in E:
    if !visited[v] && d[v] > w(u, v):
      d[v] = w(u, v)
      p[v] = u
```

