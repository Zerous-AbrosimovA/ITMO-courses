# Ссылки

```C++
int x = 1, z = 0;
int *p = &x;
f(z, &x) // z = 2, x = 3

void f(int &y (ссылка), int *q)
{
  y = 2;
  *q = 3;
}
```
Нельзя создать ссылку на ссылку, поскольку это превратится в просто ссылку
```C++
int x = 1, z = 0;
int *p = &x;
f(1, &x) // такое возможно только если в функции указан const, поскольку здесь создается объект типа x

void f(const int &y, int *q)
{
  *q = y + 1; 
}
```
```C++
int x = 1, z = 0;
int *p = &x;
int w = f(1, &x); // невалидно, поскольку мы получаем значение из области памяти, которая официально не используется
g(1, &x) = 3; // *p = 3

int &f(const int &y, int *q)
{
  int k = y + *q;
  return k;
}

int &g(const int &y, int *q)
{
  int k = y + *q;
  return *q; // по факту вернется значение x
}
```

# Значение по умолчанию

Наконец-то у нас есть значения по умолчанию 
```C++
int f(int x, int y = 3, float z = 4.5f)
{
  ...
}
```
Однако в C++ аргументы в функцию передаются последовательно => нельзя передать x и z, без передачи y

# Перегрузки

 ```C++
double s(double x)
  return (x+1);
float s(float x)
  return (x+1);
long double s(long double x)
  return (x+1);
```
На самом деле компилятор приписывает к названию каждой функции принимаемый ей тип, поэтому не происходит проблем с линковкой при перегрузке
```C++
#ifdef __cplusplus
extern "C" // объявление функции для стыковки с C
#endif
{
  int f(int x);
#ifdef __cplusplus
}
#endif
```
