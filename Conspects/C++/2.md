# Структуры 

```C++
struct A
{
  ...
};
//Создание объекта структуры
A x; // не надо писать struct A
```
```C++
struct A
{
  int a, b;
  static int g() // у статической функции нету this, однако данную функцию можно вызывать без объекта
  {
    return ...;
  }
  int f() // функция в стуруктуре
  {
    return a * b;
  }
};
// использование функции из структуры
A y;
int i = y.f();
```
В C++ у нас появляется ключевое слово `this`
```C++
struct A
{
  int a, b;
  int f();
};
int A::f() // оператор области
{
  return a * b;
}
```
```C++
int m;
int main()
{
  float m;
  ::m = 3; // обращение к глобальной переменной
}
```
## Ограничение видимости
`public:` - объявление публичных полей/функций (по умолчанию все public)\
`private:` - объявление приватных полей/функций\
`protected:` - объявление публичных полей/функций для наследников

# Класс

Класс в С++ - структура с областью видимости private

# Наследование

```C++
```C++
class A
{
  public:
  int a, b;
  int f() 
  {
    return a * b;
  }
};

class B : (опционально private/public/protected) A // B - наследник A
{
  float c;
  public:
  float fz()
    return a+c;
  float f() // сокрытие функции f из A
    return a + c;
}
```
Также в C++ поддерживается множественное наследование (однако без понимания, как это работает, лучше не реализовывать его)\
В C++ существует виртуальное наследование (путем вставки перед родителям virtual), к примеру, пусть B, C наследуются от A, D наследуется от B и C, тогда при виртуальном наследование B, C от A у всех наследников будет доступ к 1 и тому же A
```C++
class A
{
  public:
  int a, b;
  int notVirtualFunction()
    return 0;
  virtual int f() const
  {
    return a * b;
  }
  virtual int g() = 0; // виртуальная функция, которую можно реализовать в наследниках (если все функции в классе виртуальные,
то объект класса создать нельзя, то есть можно таким образом создать интерфейс)
};

class B : (опционально private/public/protected) A // B - наследник A
{
  float c;
  public:
  float fz()
    return a+c;
  int f() const 
    return a + c;
}
A a;
B b;
B *pb = &b;
A *pa;
pa = &b;
pa->f(); // вызов самой новой версии функций (если нет virtual, то вызов в зависимости от типа указателя)
```
Можно объявить функцию, как `friend` функцию, чтобы она имела доступ к private полям

# Специальные методы

```C++
class A
{
  const int c;
  int a, b = 33; // добавить в конструктор по умолчанию значение, присваиваемое полю
  public:
  A() {a=0; b=1;} // конструктор
  A(int z) {a=z; b=1;}
  A(int f, int d) : c(f), a(d), {b=123;} // конструктор, с помощью которого можно инициализировать const
  ~A () {} // деструктор
}
```
**Конструкторы не наследуются**\
**Конструкторы вызываются в строгом порядке объявления полей**
