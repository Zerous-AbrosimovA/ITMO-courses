# Лямбда функции

```c++
void f() {
  int x = 3;
  int y = []() {return 4;}(); // объявление лямбда функции с вызовом
  auto z = [](){return 4;}; // объявление без вызова
  auto zz = [](int a){return a + 4;};
}
```
Лямбда функция - это на самом деле безымянный класс, внутри которого перегружен оператор ()\
[] в функции - это оператор захвата, который в момент захвата сохраняет значение переменной
```c++
int x = 3;
auto z = [x](int a = 2){retutn a + x;}
x = 0;
int y1 = z() // 5
int y2 = z(x) // 3
```
Для возможности поменять захваченное значение следуется использовать mutable

# Классификация типов

![image](https://github.com/user-attachments/assets/4894be09-278c-4900-be66-c50c826a7deb)

xvalue - это lvalue, который сейчас умрет\
& - lvalue ссылка\
&& - rvalue ссылка\
**Важно** & prvalue создается через xvalue и const ссылка может подлючиться: const & (lvalue, rvalue, xvalue)

# Шаблоны

Мотивация - меньше кода

```c++
int abs(int x) {
  return x < 0 ? -x : x;
}
long abs(long x) {
  return x < 0 ? -x : x;
}
// Очевидно плохо, поэтому можно написать
template <typename T> T abs(T x) {
  return x < 0 ? -x : x;
}
```
Важно помнить, что шаблоны не создают функцию, а лишь описывают её\
Так же можно указать компилятору конкретный тип для функции
`x = abs<int>(x)`\
Аргументами у шаблонов могут быть константы времени компиляции, типы, union, enum, class и тд
```c++
template <typename T, int i> T max(T a, T b) {
  T x[i];
  return a > b ? a : b;
}

long x;
cin >> x;
x = max<long, 5>(x, 22);
```

## Шаблоны классов

```c++
template <typename T>
class s {
  T x;
  T f();
};

S<int> a;
```

Шаблон - это правило автогенерации, поэтому классы и функции живут своей жизнью => static для каждого класса, сгенерированного с помощью шаблона свой
