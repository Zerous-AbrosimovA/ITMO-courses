# Нововведения в C++

В C++ возможно присвоить static и глобальным переменным значения времени исполнения, поскольку они вызываются перед main, однако порядок иницализации глобальных переменных неопределен

```c++
int f(int x)
{
  static int y = x; // инициализация произойдет при первом вызове f, однако внутри данной фразы находится скрытый if
  retutn x + y;
}
```

`constinit` позволяет посчитать значение глобальной или static переменной во время компиляции, но сама переменная не является коестантой\
`constexpr` переменная теперь тоже константа, однако переменная теперь локальная переменная, которую можно использовать, как константу времени компиляции\
Также `constexpr` позволяет компилятору вычислить значение функции во время компиляции и выражение `constexpr int z = f(3)` не сломается

## структурные биндинги

```c++
int q[2] = {2, 4};
auto [a, b] = q; // a = 2, b = 4
a = 10; // q[0] = 10

auto f() {
  ...
  return {2, 4.5}
}

auto [a, b] = f(); // a - int, b - double
```

Однако структурные биндинги не работают с `constexpr`

## range-base for

```c++
int q[10] = {1, 4, 3};
for (auto x : q)
{
  x // 1, 4, 3, 0, ...
}
```

## decltype

```c++
int &x;
decltype( x + 1 ) -> int - prvalue
decltype(x) -> int& - lvalue
decltype(S()) -> S && - xvalue
```

## if constexpr

```c++
if constexpr(statement) // после компиляции останется только 1 блок
{
  ...
}
else
{
  ...
}
```

# SFINAE

Какой-то отстраненный пример...

```c++
X<T1, T2>
class S {
public:
  using a = int // typedef int a
  ...
};

S::a x = 3;
```

```c++
f(1, 2);
-----------------
template <typename T>
T f(T x, T y);
T::iterator f(T a, T b); // некоректно, то есть substitution faile, т.к у int нет iterator
```
