# namespace

```c++
namespace ABC
{
  int f() {return 5;}
  float x;
}

int main() {
  // return f() - ошибка, т.к f находится в другом пространстве имен
  return ABC::f(); // верно
}

namespace ABC
{
  int a = 4; // добавится к изначальному namespace ABC
}
```
Внутри одного namespace может быть другой namespace ~~но зачем...~~~
```c++
int main() {
  ::x; // обращение к глобальной области
}
```
## Использование using
```c++
namespace F
{
  float x;
}
namespace ABC
{
  int f() {return 5;}
  using F::x;
}
using namespace ABC;
int main() {
  ABC::x; // обращение к полю пространства имен
  f() // теперь тоже верно
  ABC::f(); // верно
}
```
## namespace std

Все, что используется в стандартных модулях обернуто в `using namespace std`, поэтому, чтобы не писать std:: в начале программы следует использовать `using namespace std;`

# new/delete

В c++ был добавлен оператор new, который позволяет динамически выделять память на куче

```c++
int p = new int;
delete p;
int p* = new int[4];
delete[] p
```
При использование new выделяет нужное количество байт + вызывает конструктор вызываемого объекта, а delete вызывает деструктор + освобождает ресурсы, однако при невозможности выделить память new бросает исключение

## Проблемы при наследование

```c++
A *p = new B; // B наследуется от A
delete p; // вызовется деструктор A, но не B, исправляется virtual деструкторами
```
# Static поля

В классах при объявление static полей они становятся общими переменными для всех экземпляров и не хранятся внутри каждого объекта\
А при объявление static метода они не имеют доступа к this и их можно вызвать без создания объекта, но при этом они не имеют доступа к не static полям\
Также static поля общие для предков и потомков

# anonymous namespace

Когда блок кода необходимо сделать невидимым за пределами файла нужно использовать анонимные пространства имен
```c++
namespace {
  int local_helper() {return 23;}
}
```

# Особенности конструкторов и деструктов при наследование

Если класс является наследником другого класса, то при создание экземпляра сначала вызовется конструктор отца, а затем потомка, однако деструкторы вызовутся в обратном порядке
