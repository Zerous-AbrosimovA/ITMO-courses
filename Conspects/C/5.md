# Еще немного про malloc

При помощи malloc не следует выделять память маленькими кусками\
malloc выделяет чуть больше памяти, чем требуется\
**Выделил памяти => обязательно освободи ее**

# Немного о многомерных массивах

## 1 случай `int **p` (массив массивов)

В данной реализации при попытке обратиться к элементу массива `p[i][j]` происходит 2 обращение к памяти

## 2 случай `int *p` (одномерный массив, симулирующий двумерный

Хранится в памяти в ввиде row-major
**Данное хранение используется при передаче аргументов командной строки в main и при обращение к `p[y * w + x]` происходит 2 обращения к памяти**\
Так как выделение памяти связано с кэшированием, то в 2 случае обращение более предсказуемо для системы, поэтому больший шанс попадания в кэш, тем самым программа работает заметно быстрее\
Важно понимать, что кэшированием занимается процессов, а оптимизацией кода - компилятор

# VMT

`f(int q[2][3]) => int(*q)[3]`\
Пусть нам дано W и H, тогда\
`int(*q)[w] = malloc(sizeof(int) * W * H)` - выделение через VMT

# Массив указателей функции

``` C
int add(int a, int b);
int sub(...);
...

int (*const fop[4])(int, int) = {add, sub, ...}
int comute(uint op, int a, int b) {
  return fop[op](a, b);
}
```
# Приведение типов

1) явное: указываем явно, на какой тип поменять `(int) x`\
2) неявное: компилятор сам приводит типы `int x = 3.7` - приведение в double
**Приводить указатель в int - плохо**

## Auto

В C23 - это автоматическое приведение типов в зависимости от присваиваемого значения переменной `auto x = 3.5` - double\
Auto лучше использовать для define

## typeof

`typeof(x) y` - создание переменной y, которая будет иметь тип переменной x\
`typeof_unqual` - создание переменной без квалификатора вверхнего уровня (const и тд)
``` C
typeof(f()) x;
if (...)
  x = f()
else
  x = g()
```
