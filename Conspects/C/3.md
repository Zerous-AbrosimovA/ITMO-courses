# Шестнадцатиричная запись дробных чисел

Пример: 0x1.8p1 (тип double) = 1.1_2*2^1 = 11 = 3\
0x6.8p-2 = 0110.1000 * 2^-2 = 1.101 = 1.625\
При ввиде числа 0x1.YpZ после запятой нужно вывести 6 символов (из-за точности float)\
Для чтение нужно писать %a\
Для печати с макс точностью нужно писать %.6a

# Массивы

`int a[10] = {1, 2, 3};` - создание массива\
При обращение к `a[10]` будет получен `Undifined behavior`\
`int q[10] = {[2] = 1, [3] = 5}`\
Двумерный массив в C - **непрерывная область памяти (row major)**\
`sizeof(q)/sizeof(q[0])` - получение **длины одномерного массива**\
Размер массива - константа времени исполнения\
`VLA` - размер массива теперь **не константа времени исполнения** (не работате в компиляторе Microsoft), но работает только внутри функции и не со статическими массивами\
VLA создает массив на стеке => легко получить stackoverflow

# Указатели

``` C
int a = 2;
int *p;
p = &a / &q[1];
// p = &5 или &(a+b) - бред
float f;
p = &f; // не скомпилится
*p = 1; // обращение сквозь указатель => a = 1
const int c = 4;
// p = &c - ошибка
int *const p = &a; // присвоить в p - нельзя, но записать сквозь p можно
int *p, x; // в данном случае p - указатель на int, а x - переменная int
int **z = &p; // указатель на указатель
void *v; // указатель на абстрактный указатель, но сквозь него невозможно обратиться
```
С/С++:\
``` C
v = p
v = z
```
C:
``` C
p = v;
z = v;
*q = 1; // q[0] = 1
p = q;
p[0] = 2;
p[3] = 4;
p = &q[1];
p[0] = 2; // p[1] = 2
```

# Арифметика указателей
``` C
p = &q[1]; // p = q + 1
p + 2; // p = &q[3]
p - q; // 1
q - p; // -1
```

# Динамическое выделение памяти для массива

``` C
int *p;
p = malloc(sizeof(int) * 100); // количество в байтах, сколько выделить памяти
free(p); // освобождение памяти
```
malloc **возращает Null, если не удалось выделить память**\
**Массив нельзя передать в другую функцию, а только указатель**
``` C
f(b, q); // b = 3 int q[10]
void f(int a, int *w) {
	w[3] = 1; // q[3] = 1
	a = 2; // b = 3
}
```
# Построение динамического массива

``` C
int *p = malloc(sizeof(*p) * w * h);
p[y*w + x]; // обращение к x, y
void f(uint w, uint h, int *z) {
	z[y*w+x] = 25;
}
f(w, h, p);
```
